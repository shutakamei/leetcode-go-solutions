# ベンチマーク結果詳細

## 実行環境

- **OS**: Linux 6.6.87.2-microsoft-standard-WSL2
- **CPU**: 12th Gen Intel(R) Core(TM) i7-12700H
- **Go Version**: 1.21+
- **アーキテクチャ**: amd64

## ベンチマーク結果

### 短い文字列での性能比較

```
BenchmarkGroupAnagrams-20                          63482             17246 ns/op
BenchmarkGroupAnagramsSorted-20                   325282              3542 ns/op
BenchmarkGroupAnagramsCountString-20              648145              1830 ns/op
BenchmarkGroupAnagramsCountArray-20               206853              5066 ns/op
```

### 長い文字列での性能比較

```
BenchmarkGroupAnagramsLongStrings/Sorted-20       304905              3889 ns/op
BenchmarkGroupAnagramsLongStrings/CountString-20  493472              2146 ns/op
BenchmarkGroupAnagramsLongStrings/CountArray-20   439186              2707 ns/op
```

## 性能分析

### 短い文字列（12 要素）での比較

| 実装方法                 | 実行回数 | 平均時間 (ns/op) | 性能向上率     | 評価       |
| ------------------------ | -------- | ---------------- | -------------- | ---------- |
| **基本実装**             | 63,482   | 17,246           | 基準           | ⭐         |
| **ソート方式**           | 325,282  | 3,542            | **4.9 倍高速** | ⭐⭐⭐     |
| **文字カウント文字列化** | 648,145  | 1,830            | **9.4 倍高速** | ⭐⭐⭐⭐⭐ |
| **文字カウント配列**     | 206,853  | 5,066            | **3.4 倍高速** | ⭐⭐⭐⭐   |

### 長い文字列（26 文字 × 6 要素）での比較

| 実装方法                 | 実行回数 | 平均時間 (ns/op) | 性能向上率     | 評価       |
| ------------------------ | -------- | ---------------- | -------------- | ---------- |
| **ソート方式**           | 304,905  | 3,889            | 基準           | ⭐⭐⭐     |
| **文字カウント文字列化** | 493,472  | 2,146            | **1.8 倍高速** | ⭐⭐⭐⭐⭐ |
| **文字カウント配列**     | 439,186  | 2,707            | **1.4 倍高速** | ⭐⭐⭐⭐   |

## 詳細分析

### 1. 基本実装（文字カウント + マップ比較）

- **時間計算量**: O(n² × k)
- **特徴**: 各文字列を既存のマップと比較するため、二重ループが必要
- **性能**: 最も遅いが、理解しやすい実装

### 2. ソート方式

- **時間計算量**: O(n × k × log k)
- **特徴**: 文字列のソートがボトルネック
- **性能**: 短い文字列では効率的、長い文字列ではソートのオーバーヘッドが大きい

### 3. 文字カウント文字列化方式（推奨）

- **時間計算量**: O(n × k)
- **特徴**:
  - ソート不要
  - 文字カウントを効率的に文字列化
  - ハッシュマップのキーとして最適
- **性能**: すべてのケースで最高性能

### 4. 文字カウント配列方式

- **時間計算量**: O(n × k)
- **特徴**:
  - 26 文字の配列を文字列化
  - 短い文字列ではオーバーヘッドが大きい
  - 長い文字列では効率的
- **性能**: 長い文字列で良好、短い文字列では劣る

## メモリ使用量の推定

### 空間計算量の比較

- **基本実装**: O(n × k) - 各文字列のマップを保持
- **ソート方式**: O(n × k) - ソートされた文字列を保持
- **文字カウント文字列化**: O(n × k) - カウント文字列を保持
- **文字カウント配列**: O(n × k) - 配列文字列を保持

### 実際のメモリ効率

1. **文字カウント文字列化**: 最も効率的（短い文字列でカウント文字列が短い）
2. **ソート方式**: 中程度（ソートされた文字列の長さは元と同じ）
3. **文字カウント配列**: 中程度（26 文字の配列を文字列化）
4. **基本実装**: 最も非効率（各文字列のマップを保持）

## 推奨事項

### 本番環境での選択

**文字カウント文字列化方式**を推奨します：

1. **最高性能**: 元の実装の 9.4 倍高速
2. **一貫性**: 短い文字列でも長い文字列でも良好な性能
3. **可読性**: 実装が理解しやすい
4. **メモリ効率**: 適切なメモリ使用量

### 使用場面別の選択

| 使用場面           | 推奨実装             | 理由               |
| ------------------ | -------------------- | ------------------ |
| **一般的な用途**   | 文字カウント文字列化 | 最高性能、一貫性   |
| **短い文字列中心** | ソート方式           | シンプル、効率的   |
| **長い文字列中心** | 文字カウント配列     | 長い文字列で効率的 |
| **学習目的**       | 基本実装             | 理解しやすい       |

## 結論

Group Anagrams 問題では、**文字カウント文字列化方式**が最も効率的な解法です。元の実装と比較して 9.4 倍の性能向上を実現し、様々な入力サイズに対応できる汎用的なソリューションを提供します。
