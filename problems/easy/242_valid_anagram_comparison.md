# Valid Anagram - 解法比較

## 概要

Valid Anagram 問題の 6 つの異なるアプローチを比較します。

## 各解法の特徴

### 1. 単一マップ法 (`isAnagram1`)

**特徴**: 最もバランスの取れた解法

- **時間複雑度**: O(n)
- **空間複雑度**: O(n)
- **利点**:
  - 理解しやすい
  - 汎用的（任意の文字セットに対応）
  - 効率的
- **欠点**: ハッシュマップのオーバーヘッド

### 2. 配列法 (`isAnagram2`)

**特徴**: 小文字のみの場合の最適解

- **時間複雑度**: O(n)
- **空間複雑度**: O(1) - 固定サイズ配列
- **利点**:
  - 最も高速
  - メモリ効率が良い
  - シンプル
- **欠点**: 小文字の英字のみに限定

### 3. ソート法 (`isAnagram3`)

**特徴**: メモリ使用量を重視する場合

- **時間複雑度**: O(n log n)
- **空間複雑度**: O(n)
- **利点**:
  - メモリ使用量が予測可能
  - 実装がシンプル
- **欠点**: ソートのオーバーヘッド

### 4. ダブルマップ法 (`isAnagram4`)

**特徴**: 現在の実装の改善版

- **時間複雑度**: O(n)
- **空間複雑度**: O(n)
- **利点**:
  - 理解しやすい
  - デバッグしやすい
- **欠点**: 2 つのマップが必要

### 5. ビットマスク法 (`isAnagram5`)

**特徴**: 特殊なケース用

- **時間複雑度**: O(n)
- **空間複雑度**: O(1)
- **利点**:
  - 非常に高速
  - メモリ効率が良い
- **欠点**:
  - 各文字が 1 回しか出現しない場合のみ
  - 小文字の英字のみ

### 6. 文字列分割法 (`isAnagram6`)

**特徴**: 現在の実装の最適化版

- **時間複雑度**: O(n log n)
- **空間複雑度**: O(n)
- **利点**:
  - 現在の実装に近い
  - 理解しやすい
- **欠点**: 文字列操作のオーバーヘッド

## 推奨使用場面

### 一般的な用途

- **推奨**: アプローチ 1（単一マップ法）
- **理由**: バランスが良く、汎用的

### パフォーマンス重視

- **推奨**: アプローチ 2（配列法）
- **理由**: 最も高速でメモリ効率が良い

### メモリ制約が厳しい場合

- **推奨**: アプローチ 3（ソート法）
- **理由**: メモリ使用量が予測可能

### 学習目的

- **推奨**: アプローチ 4（ダブルマップ法）
- **理由**: 理解しやすく、デバッグしやすい

## ベンチマーク結果（予想）

```
短い文字列（5文字）:
1. 配列法: ~50ns
2. 単一マップ法: ~100ns
3. ビットマスク法: ~80ns
4. ダブルマップ法: ~150ns
5. ソート法: ~200ns
6. 文字列分割法: ~300ns

長い文字列（26文字）:
1. 配列法: ~200ns
2. 単一マップ法: ~400ns
3. ビットマスク法: ~300ns
4. ダブルマップ法: ~600ns
5. ソート法: ~800ns
6. 文字列分割法: ~1200ns
```

## 結論

- **最適解**: アプローチ 2（配列法）- 小文字のみの場合
- **汎用解**: アプローチ 1（単一マップ法）- 一般的な用途
- **学習解**: アプローチ 4（ダブルマップ法）- 理解しやすい
